/** @param {NS} ns **/

// TODO: This is n^2, see if I need to ever optimize it.
function algorithmic_stock_trader_1(inp) {
    var i = 0;
    var max_profit = 0;
    while(i < inp.length) {
        var j = i + 1;
        while (j < inp.length) {
            max_profit = Math.max(inp[j] - inp[i], max_profit);
            j += 1;
        }
        i += 1;
    }
    return max_profit;
}

function find_largest_prime_factor(num) {
    var divisor = 2;
    while( num != 1) {
        while( num % divisor == 0) {
            num = num / divisor;
        }

    }
    return divisor;
}

// TODO: If we need to, increase performance.  Should be able to work backwards
// marking positions as finishable in O(n) time.
function total_ways_to_sum(arr) {

    function dfs(start_index, target_index, array) {
        if(start_index == target_index) {
            return true;
        }
        var i = start_index;
        while(i != start_index + array[index]) {
            if dfs(i, target_index, array) {
                return true;
            }
            i += 1;
        }
        return false;
    }

    return dfs(0, len(arr)-1, arr);
}

// TODO: there's probably a closed function for this
export function unique_paths_in_a_grid_i(inp) {
    max_row = inp[0];
    max_col = inp[1];
    row = max_row - 1;

    while (row >= 0) {

        col = max_col.length-1;
        while(col >= 0) {

            if ((row == inp.length-1)) {
                if(col == inp[row].length-1) {
                    solution[row][col] = 0;
                } else {
                    solution[row][col] = solution[row][col] + 1;
                }
            } else {
                if(col == inp[row].length-1) {
                    solution[row][col] = solution[row+1][col] + 1;
                } else {
                    solution[row][col] = solution[row+1][col] + solution[row+1][col+1];
                }
            }
            col -= 1;
        }
        row -= 1;
    }

    return solution[0][0];
}

export function unique_paths_in_a_grid_ii(inp) {
    row = inp.length-1;

    while (row >= 0) {

        col = inp[row].length-1;
        while(col >= 0) {

            if(inp[row][col] == 1) {
                solution[row][col] = 0;
            } else if ((row == inp.length-1)) {
                if(col == inp[row].length-1) {
                    solution[row][col] = 0;
                } else {
                    solution[row][col] = solution[row][col] + 1;
                }
            } else {
                if(col == inp[row].length-1) {
                    solution[row][col] = solution[row+1][col] + 1;
                } else {
                    solution[row][col] = solution[row+1][col] + solution[row+1][col+1];
                }
            }
            col -= 1;
        }
        row -= 1;
    }

    return solution[0][0];
}

export function solve_contract(ns, filename, host) {
    ns.codingcontract.attempt(get_answer(filename, host), filename, host);
}

export function get_answer(filename, host) {
    var type = ns.codingcontract.getContractType(filename, host);
    var inp = ns.codingcontract.getData(filename, host);
    if(type == "Algorithmic Stock Trader I") {
    } else if(type == "Find Largest Prime Factor") {
        return find_largest_prime_factor(1);
    } else if(type == "Subarray with Maximum Sum") {
    } else if(type == "Total Ways to Sum") {
        return total_ays_to_sum(inp);
    } else if(type == "Spiralize Matrix") {
    } else if(type == "Array Jumping Game") {
    } else if(type == "Merge Overlapping Intervals") {
    } else if(type == "Generate IP Addresses") {
    } else if(type == "Algorithmic Stock Trader I") {
        return algorithmic_stock_trader_1(inp);
    } else if(type == "Algorithmic Stock Trader II") {
    } else if(type == "Algorithmic Stock Trader III") {
    } else if(type == "Algorithmic Stock Trader IV") {
    } else if(type == "Minimum Path Sum in a Triangle") {
    } else if(type == "Unique Paths in a Grid I") {
        return unique_paths_in_a_grid_i(inp);
    } else if(type == "Unique Paths in a Grid II") {
        return unique_paths_in_a_grid_ii(inp);
    } else if(type == "Sanitize Parentheses in Expression") {
    } else if(type == "Find All Valid Math Expressions") {
    } else {
        return False;
    }
}
