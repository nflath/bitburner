/** @param {NS} ns **/
import { for_each_server } from "util.ns";

// TODO: This is n^2, see if I need to ever optimize it.
function find_largest_prime_factor(num) {
    var divisor = 2;
    var largest_divisor = 1;
    while (num != 1) {
        while (num % divisor == 0) {
            num = num / divisor;
            largest_divisor = divisor;
        }
        divisor += 1;
    }
    return largest_divisor;
}

function algorithmic_stock_trader_1(inp) {
    var i = 0;
    var max_profit = 0;
    while (i < inp.length) {
        var j = i + 1;
        while (j < inp.length) {
            max_profit = Math.max(inp[j] - inp[i], max_profit);
            j += 1;
        }
        i += 1;
    }
    return max_profit;
}

function array_jumping(arr) {

    var result_arr = new Array(arr.length);
    var i = arr.length - 1;
    result_arr[i] = true;
    i = i - 1;
    while (i >= 0) {
        var j = 0;

        while ((i + j) < arr.length && j <= arr[i]) {
            if (result_arr[i + j] == true) {
                result_arr[i] = true;
            }
            j += 1;
        }

        i -= 1;
    }

    return result_arr;
}

export function unique_paths_in_a_grid_i(inp) {
    var max_row = inp[0];
    var max_col = inp[1];
    if (max_row == 1 || max_col == 1) {
        return 1;
    }
    return unique_paths_in_a_grid_i([max_row - 1, max_col]) +
        unique_paths_in_a_grid_i([max_row, max_col - 1]);
}

function unique_paths_in_a_grid_ii(inp) {
    var row = inp.length - 1;
    var solution = new Array(inp.length);
    var i = 0;
    while (i < solution.length) {
        solution[i] = new Array(inp[i].length);
        i += 1;
    }
    while (row >= 0) {

        var col = inp[row].length - 1;
        while (col >= 0) {


            if (inp[row][col] == 1) {
                solution[row][col] = 0;
            } else if ((row == inp.length - 1) &&
                (col == inp[row].length - 1)) {
                solution[row][col] = 1;
            }
            else if ((row == inp.length - 1)) {
                solution[row][col] = solution[row][col + 1];
            } else if (col == inp[row].length - 1) {
                solution[row][col] = solution[row + 1][col];
            } else {
                solution[row][col] = solution[row + 1][col] + solution[row][col + 1];
            }
            col -= 1;

        }
        row -= 1;
    }

    return solution[0][0];
}

function spiralize_matrix(inp) {
    const result = [];
    let h = matrix.length;
    let w = matrix[0].length;

    if(w === 1 && h === 1) return [matrix[0][0]];

    var r = 0;
    var c = 0;

    while(w > 1 && h > 1){

        // top horizontal
        for(let col=c; col<c + w; col++) {
            result.push(matrix[r][col]);
        }

        // right vertical
        for(let row=r + 1; row < r + h - 1; row++){
            result.push(matrix[row][c + w - 1]);
        }

        // bottom horizontal
        for(let col=c + w - 1; col >= r; col--){
            result.push(matrix[r + h - 1][col]);
        }

        // left vertical
        for(let row = r + h - 2; row >= r + 1; row--){
            result.push(matrix[row][c]);
        }

        w -= 2;
        h -= 2;
        r++;
        c++;
    }

    if(w <= 0 || h <= 0) return result;

    if(w === 1){
        for(let row = r; row< r + h; row++){
            result.push(matrix[row][c]);
        }
    }
    else{
        for(let col = c; col < c + w; col++){
           result.push(matrix[r][col]);
       }
    }


    return result;
};


var types_seen = {};
export async function get_answer(ns, host, filename) {
    var type = ns.codingcontract.getContractType(filename, host);
    types_seen[type] = 1
    var inp = ns.codingcontract.getData(filename, host);
    var answer = false;
    ns.print("get_answer: ", filename, " ", host, type, " ", inp);
    if (type == "Find Largest Prime Factor") {
        anwer = find_largest_prime_factor(inp);
    } else if (type == "Subarray with Maximum Sum") {
    } else if (type == "Total Ways to Sum") {
    } else if (type == "Spiralize Matrix") {
        answer = spiralize_matrix(inp);
    } else if (type == "Array Jumping Game") {
        answer = array_jumping(inp);
    } else if (type == "Merge Overlapping Intervals") {
    } else if (type == "Generate IP Addresses") {
    } else if (type == "Algorithmic Stock Trader I") {
        answer = algorithmic_stock_trader_1(inp);
    } else if (type == "Algorithmic Stock Trader II") {
    } else if (type == "Algorithmic Stock Trader III") {
    } else if (type == "Algorithmic Stock Trader IV") {
    } else if (type == "Minimum Path Sum in a Triangle") {
    } else if (type == "Unique Paths in a Grid I") {
        answer = unique_paths_in_a_grid_i(inp);
    } else if (type == "Unique Paths in a Grid II") {
        answer = unique_paths_in_a_grid_ii(inp);
    } else if (type == "Sanitize Parentheses in Expression") {
    } else if (type == "Find All Valid Math Expressions") {
    }
    if(answer == false) {
        types_seen[type] = 0;
    }
    return answer;
};

var solved_contracts = {};
var failed_contracts = {};

async function solve_all_contracts(ns) {
    var solved_contracts = [];
    await for_each_server(ns, async function (ns, server) {


        for (let file of ns.ls(server)) {
            if ([server, file] in solved_contracts) {
                continue;
            }
            if ([server, file] in failed_contracts) {
                continue;
            }
            if (file.slice(file.length - 3) == "cct") {
                ns.print("NS:", ns, ns.codingcontract);
                var ans = await get_answer(ns, server, file);
                if (ans != false) {
                    ns.print("Answer: ", ans);
                    var result = ns.codingcontract.attempt(ans, file, server);
                     if (result != false) {
                        solved_contracts[[server, file]] = true;
                        ns.print("Solved contract:", server, " ", file);
                    } else {
                        failed_contracts[[server, file]] = true;
                        ns.print("Failed contract:", server, file);
                        await ns.sleep(100000);

                    }
                }
            }
        }
    });
    ns.print("Seen: ",types_seen);
    ns.print("Solved: ",solved_contracts);
    ns.print("Failed: ",failed_contracts);
}


export async function main(ns) {
    await solve_all_contracts(ns);
    ns.print(types_seen);
}
