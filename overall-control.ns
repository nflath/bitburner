// TODO: Better optimization of hack/weaken/grow.
// TODO: Memory change on home computer
// TODO: What can be automated? Crime?  Factions?  Augmentation aquiring?  Augmentation installing? Buy darkweb connection? Buying *from* darkweb?
import {get_total_ram, get_server_max_ram, for_each_server, install_script_on_all_servers, setup_servers} from "util.ns";
import {upgrade_hacknodes} from "hacknet.ns";

// Todo: Split advanced scheudle rto different file

var weaken_fraction = .25;
var grow_fraction = .73;
var hack_fraction = .02;

class Op {
    constructor(op_script, threads, target) {
        this.op_script = op_script;
        this.threads = threads;
        this.target = target;
    }
}

// Returns the 'best' server to hack.
// TODO: May want to round-robin these.
async function GetServerToHack(ns) {
    var server_to_required_hacking_level = {};
    var server_to_max_money = {};

    await for_each_server(ns, async function (ns, server) {
        if(ns.hasRootAccess(server)) {
            server_to_required_hacking_level[server] = ns.getServerRequiredHackingLevel(server);
            server_to_max_money[server] = ns.getServerMaxMoney(server);
        }
    });

    var server_to_hack = ["n00dles", ns.getServerMaxMoney("n00dles")];
    var hacking_level = ns.getHackingLevel();

    // TODO: use maximum money instead of hacking difficulty
    for(let server of Object.keys(server_to_required_hacking_level)) {
        var possible_hacking_level = server_to_required_hacking_level[server];
        if(possible_hacking_level * 4 < hacking_level) {
            if(server_to_max_money[server] > server_to_hack[1]) {
                server_to_hack = [server, server_to_max_money[server]];
            }
        }
    }
    return server_to_hack[0];
}

async function GetAllHackableServers(ns) {
    var hackable_servers = [];
    await for_each_server(ns, async function (ns, server) {
        if(ns.hasRootAccess(server) && ns.getServerMaxMoney(server) != 0) {
            ns.print("Hackable server: ", server)
            hackable_servers.push(server);
        }
    });
    return hackable_servers;
}

async function schedule(ns, target, op, max_threads_per_second, queues, offset) {
    ns.print("Scheduling for ", op);

    var ram_fraction = 0;
    var script_ram = 0;
    var op_script = "";
    var op_time = 0;
    var q = null;
    if (op == 'weaken') {
        // assert(len(queues.weaken) == 0)
        ram_fraction = weaken_fraction;
        op_script = "weaken.ns";
        op_time = Math.floor(offset+ns.formulas.hacking.weakenTime(ns.getServer(target),ns.getPlayer())/1000);
        q = queues['weaken'];
    }

    if (op == 'grow') {
        // assert(len(queues.grow) == 0)
        ram_fraction = grow_fraction;
        op_script = "grow.ns";
        op_time = Math.floor(offset+ns.formulas.hacking.growTime(ns.getServer(target),ns.getPlayer())) / 1000;
        q = queues['grow'];
    }

    if (op == 'hack') {
        //assert(len(queues.hack) == 0)
        ram_fraction = hack_fraction;
        op_script = "hack.ns";
        op_time = Math.floor(offset+ns.formulas.hacking.hackTime(ns.getServer(target),ns.getPlayer())) / 1000;
        q = queues['hack'];
    }

    var total_ram = await get_total_ram(ns);
    ns.print("Returned total_ram: ", total_ram);
    var total_ram_for_op = total_ram * ram_fraction;
    var total_num_threads = Math.floor(total_ram_for_op / ns.getScriptRam(op_script));
    var threads_per_second = total_num_threads / op_time;
    if(max_threads_per_second > 0 && threads_per_second > max_threads_per_second) {
        threads_per_second = max_threads_per_second;
    }

    var i = 0;
    var scheduled = 0;
    while(i <= op_time) {
        i++;
        var total_desired_scheduled = Math.floor(threads_per_second * (i));
        q.push( [Date.now() + i*1000, new Op(op_script, total_desired_scheduled-scheduled, target)] );
        scheduled = total_desired_scheduled;
    }
}

export async function GetNewServers(ns, ram) {
   var i = 0;
   while (i < ns.getPurchasedServerLimit()) {
       var hostname = "pserv-" + i;
       if(ns.serverExists(hostname)) {
           ns.deleteServer(hostname);
       }
       ns.purchaseServer(hostname, ram);
       ++i;
   }
}

export async function run_op(ns, op, ts) {
    var remaining_threads = op.threads;
    await for_each_server(ns, async function(ns, server) {
        if(remaining_threads >= 0) {
            var num_threads_can_run = (await get_server_max_ram(ns,server)-await ns.getServerUsedRam(server))/await ns.getScriptRam(op.op_script);
            var threads_to_run = Math.min(num_threads_can_run, remaining_threads);
            remaining_threads -= threads_to_run;
            ns.print("threads_to_run: ", threads_to_run, " op.threads: ", op.threads);
            if(threads_to_run > 0) {
                ns.exec(op.op_script, server, threads_to_run, op.target, ts);
            }
        }
    });
}

export async function main(ns) {
    // Always run an install first
    var server_to_hack = await GetServerToHack(ns);
    var has_file = {
        "BruteSSH.exe" : false,
        "FTPCrack.exe" : false,
        "relaySMTP.exe" : false,
        "HTTPWorm.exe" : false,
        "SQLInject.exe" : false,
        "Formulas.exe" : false,
    };

    var extra_server_ram = 2;
    if(ns.serverExists("pserv-0")) {
      extra_server_ram = ns.getServerMaxRam("pserv-0");
    }

    var queues = {
        'hack' : [],
        'weaken': [],
        'grow': []
    };
    var max_last_threads = {
        'hack' : 0,
        'weaken': 0,
        'grow': 0
    };

    var reschedules = 0;
    var changed = true;

    while(true) {

        // Try to upgrade hacknodes
        await upgrade_hacknodes(ns);

        // Check if we have aquired any files since last tick.
        var files_in_home = ns.ls("home");
        for(let file in Object.keys(has_file)) {
            if(!has_file[file] && files_in_home.includes(file)) {
                changed = true;
                has_file[file] = true;
            }
        }

        // Check if we want to change which server to hack.
        if(server_to_hack != await GetServerToHack(ns)) {
            changed = true;
            server_to_hack = await GetServerToHack(ns);
        }

        // Calculate if we can buy extra RAM for our servers
        var extra_server_ram_can_afford = extra_server_ram;
        while(ns.getServerMoneyAvailable("home") > (ns.getPurchasedServerLimit() * ns.getPurchasedServerCost(extra_server_ram_can_afford))) {
            extra_server_ram_can_afford *= 2;
        }

        if(extra_server_ram_can_afford > extra_server_ram) {
            changed = true;
            await GetNewServers(ns, extra_server_ram_can_afford);
            extra_server_ram = extra_server_ram_can_afford;

        }

        ns.print("Changed", changed, ns.ls("home").includes("Formulas.exe"));

        if(changed) {
            await setup_servers(ns);
            if(ns.ls("home").includes("Formulas.exe")) {
                ns.print("Scheduling");
                queues = {
                    'hack' : [],
                    'weaken': [],
                    'grow': []
                };
                reschedules = 0;
                await schedule(ns, server_to_hack , 'weaken', 0, queues, 0);
                await schedule(ns, server_to_hack , 'grow', 0, queues, 0);
                await schedule(ns, server_to_hack , 'hack', 0, queues, queues['weaken'].length * 1000);
                max_last_threads = {
                    'hack' : 0,
                    'weaken': 0,
                    'grow': 0
                };
            } else {
                // We don't have formulas.exe installed, just fall back
                var hackable_servers = await GetAllHackableServers(ns);

                var i = 0;

                await for_each_server(ns, async function (ns, server) {
                    if (ns.hasRootAccess(server)) {
                        var num_threads = Math.floor( (await get_server_max_ram(ns, server) - await ns.getServerUsedRam(server)) / await ns.getScriptRam("early-hack-template.ns"));
                        ns.exec("early-hack-template.ns", server, num_threads, hackable_servers[i]);
                        i = (i + 1) % hackable_servers.length;
                    }
                });
            }
        }

        if(ns.ls("home").includes("Formulas.exe")) {
            for(let q of Object.keys(queues)) {
                var last_threads_per_second = 0;
                while(queues[q].length > 0 &&
                      queues[q][0][0] < Date.now()) {
                    await run_op(ns, queues[q][0][1], queues[q][0][0]);
                    last_threads_per_second = queues[q][0][1].threads;
                    queues[q].splice(0,1);
                }
                max_last_threads[q] = Math.max(max_last_threads[q], last_threads_per_second);
                if(queues[q].length == 0) {
                    if(reschedules >= 1000) {
                        changed = true;
                    }
                    reschedules += 1;
                    await schedule(ns, server_to_hack, q, last_threads_per_second, queues, 0);
                }
            }
        }
        changed = false
        await ns.sleep(1000); // Sleep for 1 second.
    }
}
