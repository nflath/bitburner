// TODO: Better optimization of hack/weaken/grow.
// TODO: Memory change on home computer
// TODO: What can be automated? Crime?  Factions?  Augmentation aquiring?  Augmentation installing? Buy darkweb connection? Buying *from* darkweb?
import {get_total_ram, get_server_max_ram, for_each_server, install_script_on_all_servers, setup_servers} from "util.ns";
import {upgrade_hacknodes} from "hacknet.ns";

// Todo: Split advanced scheudle rto different file

var weaken_fraction = .25;
var grow_fraction = .73;
var hack_fraction = .02;

class Op {
    constructor(op_script, threads, target) {
        this.op_script = op_script;
        this.threads = threads;
        this.target = target;
    }
}

// TODO: Unused now, need singularity API
var SERVERS_TO_HACK = ["CSEC","I.I.I.I", "avmnite-02h", "run4theh111z", "fulcrumassets"];
var SERVERS_HACKED = [];

// Returns the 'best' server to hack.
// TODO: May want to round-robin these.
async function GetServerToHack(ns) {
    var hacking_level_multiplier = .25;
    var server_to_required_hacking_level = {};

    await for_each_server(ns, async function (ns, server) {
        if(ns.hasRootAccess(server)) {
            server_to_required_hacking_level[server] = ns.getServerRequiredHackingLevel(server);
        }
    });

    var server_to_hack = ["n00dles", 0];
    var hacking_level = ns.getHackingLevel();

    // TODO: use maximum money instead of hacking difficulty
    for(let server of Object.keys(server_to_required_hacking_level)) {
        var val = server_to_required_hacking_level[server];
        if(val * 4 < hacking_level) {
            if(val > server_to_hack[1]) {
                server_to_hack = [server, val];
            }
        }
    }
    return server_to_hack[0];
}

async function schedule(ns, target, op, max_threads_per_second, queues, offset) {
    ns.print("Scheduling for ", op);
    var fn = null;

    var ram_fraction = 0;
    var script_ram = 0;
    var op_script = "";
    var op_time = 0;
    var q = null;
    if (op == 'weaken') {
        // assert(len(queues.weaken) == 0)
        ram_fraction = weaken_fraction;
        op_script = "weaken.ns";
        op_time = Math.floor(offset+ns.formulas.hacking.weakenTime(ns.getServer(target),ns.getPlayer())/1000);
        q = queues['weaken'];
    }

    if (op == 'grow') {
        // assert(len(queues.grow) == 0)
        ram_fraction = grow_fraction;
        op_script = "grow.ns";
        op_time = Math.floor(offset+ns.formulas.hacking.growTime(ns.getServer(target),ns.getPlayer())) / 1000;
        q = queues['grow'];
    }

    if (op == 'hack') {
        //assert(len(queues.hack) == 0)
        ram_fraction = hack_fraction;
        op_script = "hack.ns";
        op_time = Math.floor(offset+ns.formulas.hacking.hackTime(ns.getServer(target),ns.getPlayer())) / 1000;
        q = queues['hack'];
    }

    var total_ram = await get_total_ram(ns);
    ns.print("Returned total_ram: ", total_ram);
    var total_ram_for_op = total_ram * ram_fraction;
    var total_num_threads = Math.floor(total_ram_for_op / ns.getScriptRam(op_script));
    var threads_per_second = total_num_threads / op_time;
    if(max_threads_per_second > 0 && threads_per_second > max_threads_per_second) {
        threads_per_second = max_threads_per_second;
    }

    var i = 0;
    var scheduled = 0;
    while(i <= op_time) {
        i++;
        var total_desired_scheduled = Math.floor(threads_per_second * (i));
        q.push( [Date.now() + i*1000, new Op(op_script, total_desired_scheduled-scheduled, target)] );
        scheduled = total_desired_scheduled;
    }
}

export async function GetNewServers(ns, ram) {
   var i = 0;
   while (i < ns.getPurchasedServerLimit()) {
       var hostname = "pserv-" + i;
       if(ns.serverExists(hostname)) {
           ns.deleteServer(hostname);
       }
       ns.purchaseServer(hostname, ram);
       ++i;
   }
}

export async function run_op(ns, op, ts) {
    var remaining_threads = op.threads;
    await for_each_server(ns, async function(ns, server) {
        if(remaining_threads >= 0) {
            var num_threads_can_run = (await get_server_max_ram(ns,server)-await ns.getServerUsedRam(server))/await ns.getScriptRam(op.op_script);
            var threads_to_run = Math.min(num_threads_can_run, remaining_threads);
            remaining_threads -= threads_to_run;
            ns.print("threads_to_run: ", threads_to_run, " op.threads: ", op.threads);
            if(threads_to_run > 0) {
                ns.exec(op.op_script, server, threads_to_run, op.target, ts);
            }
        }
    });
}

export async function main(ns) {
    // Always run an install first

    var files = ns.ls("home");

    var server_to_hack = await GetServerToHack(ns);
    var has_brutessh = false;
    var has_ftpcrack = false;
    var has_relaysmtp = false;
    var has_httpworm = false;
    var has_sqlinject = false;
    var has_formulas = false;

    var extra_server_ram = 2;
    if(ns.serverExists("pserv-0")) {
      extra_server_ram = ns.getServerMaxRam("pserv-0");
    }

    var queues = {
        'hack' : [],
        'weaken': [],
        'grow': []
    };
    var max_last_threads = {
        'hack' : 0,
        'weaken': 0,
        'grow': 0
    };

    var reschedules = 0;
    while(true) {
        // Try to upgrade hacknodes
        await upgrade_hacknodes(ns);

        files = ns.ls("home");

        // Check if anything has changed since last run
        var changed = false;
        if(!has_brutessh && files.includes("BruteSSH.exe")) {
            changed = true;
            has_brutessh = true;
        }
        if(!has_formulas && files.includes("Formulas.exe")) {
            changed = true
            has_formulas = true;
        }
        if(!has_ftpcrack && files.includes("FTPCrack.exe")) {
            changed = true;
            has_ftpcrack = true;
        }
        if(!has_relaysmtp && files.includes("relaySMTP.exe")) {
            changed = true;
            has_relaysmtp = true;
        }
        if(!has_httpworm && files.includes("HTTPWorm.exe")) {
            changed = true;
            has_httpworm = true;
        }
        if(!has_sqlinject && files.includes("SQLInject.exe")) {
            changed = true;
            has_sqlinject = true;
        }
        if(server_to_hack != await GetServerToHack(ns)) {
            changed = true;
            server_to_hack = await GetServerToHack(ns);
        }


        // Calculate if we can buy extra RAM for our servers
        var extra_server_ram_can_afford = extra_server_ram;
        while(ns.getServerMoneyAvailable("home") > (ns.getPurchasedServerLimit() * ns.getPurchasedServerCost(extra_server_ram_can_afford))) {
            extra_server_ram_can_afford *= 2;
        }

        if(extra_server_ram_can_afford > extra_server_ram) {
            await GetNewServers(ns, extra_server_ram_can_afford);
            extra_server_ram = extra_server_ram_can_afford;
            changed = true;
        }

        ns.print("Changed", changed, ns.ls("home").includes("Formulas.exe"));

        if(changed) {
            await setup_servers(ns);
            if(ns.ls("home").includes("Formulas.exe")) {
                ns.print("Scheduling");
                queues = {
                    'hack' : [],
                    'weaken': [],
                    'grow': []
                };
                reschedules = 0;
                await schedule(ns, server_to_hack , 'weaken', 0, queues, 0);
                await schedule(ns, server_to_hack , 'grow', 0, queues, 0);
                await schedule(ns, server_to_hack , 'hack', 0, queues, queues['weaken'].length * 1000);
                max_last_threads = {
                    'hack' : 0,
                    'weaken': 0,
                    'grow': 0
                };
            } else {
                // We don't have formulas.exe installed, just fall back
                ns.print("Installing targeting ", server_to_hack);
                await install_script_on_all_servers(ns, "early-hack-template.ns", server_to_hack);
            }
        }
        if(ns.ls("home").includes("Formulas.exe")) {
            for(let q of Object.keys(queues)) {
                var last_threads_per_second = 0;
                while(queues[q].length > 0 &&
                      queues[q][0][0] < Date.now()) {
                    await run_op(ns, queues[q][0][1], queues[q][0][0]);
                    last_threads_per_second = queues[q][0][1].threads;
                    queues[q].splice(0,1);
                }
                max_last_threads[q] = Math.max(max_last_threads[q], last_threads_per_second);
                if(queues[q].length == 0) {
                    if(reschedules >= 1000) {
                        changed = true;
                    }
                    reschedules += 1;
                    await schedule(ns, server_to_hack, q, last_threads_per_second, queues, 0);
                }
            }
        }

        await ns.sleep(1000); // Sleep for 1 second.
    }
}
