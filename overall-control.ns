// TODO: Better optimization of hack/weaken/grow.
// TODO: Memory change on home computer
// TODO: What can be automated? Crime?  Factions?  Augmentation aquiring?  Augmentation installing? Buy darkweb connection? Buying *from* darkweb?
import {get_total_ram, get_server_max_ram, for_each_server, setup_servers} from "util.ns";
import {upgrade_hacknodes} from "hacknet.ns";
import {GetAdvancedScheduler} from "advanced_scheduler.ns";
import {GetBasicScheduler} from "basic_scheduler.ns";

async function schedule(ns, target, op, max_threads_per_second, queues, offset) {
    ns.print("Scheduling for ", op);

    var ram_fraction = 0;
    var script_ram = 0;
    var op_script = "";
    var op_time = 0;
    var q = null;
    if (op == 'weaken') {
        // assert(len(queues.weaken) == 0)
        ram_fraction = weaken_fraction;
        op_script = "weaken.ns";
        op_time = Math.floor(offset+ns.formulas.hacking.weakenTime(ns.getServer(target),ns.getPlayer())/1000);
        q = queues['weaken'];
    }

    if (op == 'grow') {
        // assert(len(queues.grow) == 0)
        ram_fraction = grow_fraction;
        op_script = "grow.ns";
        op_time = Math.floor(offset+ns.formulas.hacking.growTime(ns.getServer(target),ns.getPlayer())) / 1000;
        q = queues['grow'];
    }

    if (op == 'hack') {
        //assert(len(queues.hack) == 0)
        ram_fraction = hack_fraction;
        op_script = "hack.ns";
        op_time = Math.floor(offset+ns.formulas.hacking.hackTime(ns.getServer(target),ns.getPlayer())) / 1000;
        q = queues['hack'];
    }

    var total_ram = await get_total_ram(ns);
    ns.print("Returned total_ram: ", total_ram);
    var total_ram_for_op = total_ram * ram_fraction;
    var total_num_threads = Math.floor(total_ram_for_op / ns.getScriptRam(op_script));
    var threads_per_second = total_num_threads / op_time;
    if(max_threads_per_second > 0 && threads_per_second > max_threads_per_second) {
        threads_per_second = max_threads_per_second;
    }

    var i = 0;
    var scheduled = 0;
    while(i <= op_time) {
        i++;
        var total_desired_scheduled = Math.floor(threads_per_second * (i));
        q.push( [Date.now() + i*1000, new Op(op_script, total_desired_scheduled-scheduled, target)] );
        scheduled = total_desired_scheduled;
    }
}

export async function GetNewServers(ns, ram) {
   var i = 0;
   while (i < ns.getPurchasedServerLimit()) {
       var hostname = "pserv-" + i;
       if(ns.serverExists(hostname)) {
           ns.deleteServer(hostname);
       }
       ns.purchaseServer(hostname, ram);
       ++i;
   }
}

export async function run_op(ns, op, ts) {
    var remaining_threads = op.threads;
    await for_each_server(ns, async function(ns, server) {
        if(remaining_threads >= 0) {
            var num_threads_can_run = (await get_server_max_ram(ns,server)-await ns.getServerUsedRam(server))/await ns.getScriptRam(op.op_script);
            var threads_to_run = Math.min(num_threads_can_run, remaining_threads);
            remaining_threads -= threads_to_run;
            ns.print("threads_to_run: ", threads_to_run, " op.threads: ", op.threads);
            if(threads_to_run > 0) {
                ns.exec(op.op_script, server, threads_to_run, op.target, ts);
            }
        }
    });
}

export async function main(ns) {
    // Always run an install first
    var has_file = {
        "BruteSSH.exe" : false,
        "FTPCrack.exe" : false,
        "relaySMTP.exe" : false,
        "HTTPWorm.exe" : false,
        "SQLInject.exe" : false,
        "Formulas.exe" : false,
    };

    var extra_server_ram = 2;
    if(ns.serverExists("pserv-0")) {
      extra_server_ram = ns.getServerMaxRam("pserv-0");
    }

    var queues = {
        'hack' : [],
        'weaken': [],
        'grow': []
    };
    var max_last_threads = {
        'hack' : 0,
        'weaken': 0,
        'grow': 0
    };

    var scheduler = null;
    var changed = true;

    while(true) {

        // Try to upgrade hacknodes
        await upgrade_hacknodes(ns);

        // Check if we have aquired any files since last tick.
        var files_in_home = ns.ls("home");
        for(let file in Object.keys(has_file)) {
            if(!has_file[file] && files_in_home.includes(file)) {
                changed = true;
                has_file[file] = true;
            }
        }

        // Calculate if we can buy extra RAM for our servers
        var extra_server_ram_can_afford = extra_server_ram;
        while(ns.getServerMoneyAvailable("home") > (ns.getPurchasedServerLimit() * ns.getPurchasedServerCost(extra_server_ram_can_afford))) {
            extra_server_ram_can_afford *= 2;
        }

        if(extra_server_ram_can_afford > extra_server_ram) {
            changed = true;
            await GetNewServers(ns, extra_server_ram_can_afford);
            extra_server_ram = extra_server_ram_can_afford;

        }

        ns.print("Changed", changed, ns.ls("home").includes("Formulas.exe"));

        if(changed) {
            ns.print("Changed")
            await setup_servers(ns);
            if(ns.ls("home").includes("Formulas.exe")) {
                scheduler = GetAdvancedScheduler(ns);
                ns.print("GetAdvancedScheduler");
            } else {
                scheduler = GetBasicScheduler(ns);
            }
            ns.print(scheduler);
            await scheduler.initialize();
        }
        ns.print("About to tick ", Date.now());
        await scheduler.tick();
        ns.print("Tickeed", Date.now());
        changed = false;
        await ns.sleep(1000); // Sleep for 1 second.
        await ns.print("Sleeped", Date.now());
    }
}
